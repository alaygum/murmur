<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ú—É—Ä–º—É—Ä</title>

  <style>

    html, body {
  height: 100%;
  width: 100%;
  margin: 0;
}

html {
  background: #f0f8ff;
}

    body {
      font-family: 'Avenir Next', 'Futura', 'Century Gothic', 'Arial', sans-serif;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
      margin: 0;
      overflow: hidden;
      position: relative;
      isolation: isolate;

    }

body::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: -1;
  background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 50%, #d4ecff 100%);
  transform: translateZ(0);
  backface-visibility: hidden;
  -webkit-transform: translateZ(0);
  will-change: transform;
}

    
    .container {
      text-align: center;
      padding: 20px;
      max-width: 600px;
      width: 100%;
    }

    .screen {
      display: grid;
      grid-template-rows: auto auto auto;
      row-gap: 30px;
      align-items: start;
      justify-items: center;
    }

    .titleBlock{
      width: 100%;
      min-height: 92px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #3a7bd5;
      text-align: center;
      line-height: 1.25;
      letter-spacing: 0.02em;
      font-weight: 600;
      font-size: clamp(1.8rem, 5vw, 2.5rem);
    }

    .titleBlock .line {
      display: block;
    }

    .gif-container {
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .gif-container img {
      max-width: 300px;
      width: 100%;
      height: auto;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(58, 123, 213, 0.15);
      background: rgba(255,255,255,0.5);
      display:block;
    }

    .stage {
      width: 100%;
      min-height: 120px;
      padding: 20px;
      position: relative;
      touch-action: none;
      user-select: none;
    }

    .btn {
      height: 52px;
      min-width: 120px;
      padding: 14px 40px;
      font-size: 1.1rem;
      font-weight: 500;
      border-radius: 12px;
      border: 0;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      font-family: inherit;
    }

    .yesBtn {
      background: linear-gradient(135deg, #6dd5ed 0%, #2193b0 100%);
      color: #ffffff;
      box-shadow: 0 4px 20px rgba(33, 147, 176, 0.4);
      cursor: pointer;
      transition: transform .14s ease, filter .14s ease;
    }

    .yesBtn:hover {
      transform: translate(-50%, -50%) scale(1.06);
      filter: brightness(1.03);
    }

    .noBtn {
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
      color: #666666;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
      cursor: not-allowed;
      pointer-events: none;
    }

    .hidden { display: none; }

    .puff{
      position: fixed;
      left: 0;
      top: 0;
      z-index: 50;
      pointer-events:none;
      font-size: 20px;
      --rot: 0deg;
      --dx1: 0px;
      --dy1: 0px;
      --dx2: 0px;
      --dy2: 0px;
      animation: puffOut .62s ease forwards;
      transform: translate(-50%, -50%) rotate(var(--rot)) scale(0.9);
      opacity: 0;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,0.20));
    }

    @keyframes puffOut{
      0%{ opacity: 0; transform: translate(-50%, -50%) rotate(var(--rot)) scale(0.7); }
      16%{ opacity: 1; transform: translate(calc(-50% + var(--dx1)), calc(-50% + var(--dy1))) rotate(var(--rot)) scale(1.0); }
      100%{ opacity: 0; transform: translate(calc(-50% + var(--dx2)), calc(-50% + var(--dy2))) rotate(var(--rot)) scale(1.25); }
    }

    canvas.confetti{
      position: fixed;
      inset: 0;
      z-index: 60;
      pointer-events: none;
      display:none;
    }
    canvas.confetti.on{ display:block; }

    @media (prefers-reduced-motion: reduce){
      .yesBtn{ transition:none; }
    }

    @media (max-width: 420px){
      .container{ padding: 16px; }
      .stage{ padding: 14px; min-height: 130px; }
      .btn{
        padding: 12px 26px;
        min-width: 108px;
        font-size: 1.0rem;
      }
      .titleBlock{
        min-height: 86px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div id="viewAsk" class="screen">
      <div class="titleBlock">
        <span class="line">–¢—ã –±—É–¥–µ—à—å –º–æ–∏–º –ú—É—Ä–º—É—Ä–æ–º?</span>
      </div>

      <div class="gif-container" id="askGifWrap">
        <img id="askGif" src="ask.gif" alt="–ö–æ—Ç—ë–Ω–æ–∫" loading="eager" decoding="sync" />
      </div>

      <div class="stage" id="stage">
        <button class="btn yesBtn" id="yesBtn">–î–∞ ü•ê</button>
        <button class="btn noBtn" id="noBtn" aria-disabled="true" tabindex="-1">–ù–µ—Ç</button>
      </div>
    </div>

    <div id="viewYes" class="screen hidden">
      <div class="titleBlock">
        <span class="line">–£—Ä–∞!</span>
        <span class="line">–ú–æ–π –ª—é–±–∏–º—ã–π –ª–∞—Å–∫–æ–≤—ã–π –ú—É—Ä–º—É—Ä!</span>
      </div>

      <div class="gif-container" id="celebrateGifWrap">
        <img id="celebrateGif" src="celebrate.gif" alt="–ü—Ä–∞–∑–¥–Ω–æ–≤–∞–Ω–∏–µ" loading="eager" decoding="sync" />
      </div>

      <div class="stage" aria-hidden="true"></div>
    </div>
  </div>

  <canvas class="confetti" id="confetti"></canvas>

  <script>
    const prefersReducedMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    const stage = document.getElementById("stage");
    const yesBtn = document.getElementById("yesBtn");
    const noBtn = document.getElementById("noBtn");

    const viewAsk = document.getElementById("viewAsk");
    const viewYes = document.getElementById("viewYes");

    let askGif = document.getElementById("askGif");
    let celebrateGif = document.getElementById("celebrateGif");

    const askGifWrap = document.getElementById("askGifWrap");
    const celebrateGifWrap = document.getElementById("celebrateGifWrap");

    const confettiCanvas = document.getElementById("confetti");
    const ctx = confettiCanvas.getContext("2d");

    function forceRestartGif(img, file){
      const clone = img.cloneNode(true);
      clone.src = file + "?v=" + Date.now();
      img.parentNode.replaceChild(clone, img);
      return clone;
    }

    function restartGifsIfIOS(){
      if (!isIOS) return;
      askGif = forceRestartGif(askGif, "ask.gif");
      celebrateGif = forceRestartGif(celebrateGif, "celebrate.gif");
    }

    restartGifsIfIOS();

    document.addEventListener("visibilitychange", () => {
      if (!isIOS) return;
      if (document.visibilityState === "visible") {
        if (!viewAsk.classList.contains("hidden")) askGif = forceRestartGif(askGif, "ask.gif");
        if (!viewYes.classList.contains("hidden")) celebrateGif = forceRestartGif(celebrateGif, "celebrate.gif");
      }
    });

    function clamp(v, a, b){
      return Math.max(a, Math.min(b, v));
    }

    function rectsOverlap(a, b){
      return !(b.left > a.right || b.right < a.left || b.top > a.bottom || b.bottom < a.top);
    }

    function inflateRect(r, pad){
      return { left:r.left-pad, right:r.right+pad, top:r.top-pad, bottom:r.bottom+pad };
    }

    const NO = {
      safeDist: 120,
      step: 78,
      jitter: 16,
      margin: 14,
      yesPad: 46,
      historyN: 10,
      historyMinSep: 72,
      samplesNear: 140,
      samplesGlobal: 110
    };

    let noPos = { x: 0, y: 0 };
    let history = [];
    let rafId = null;

    function stageRect(){
      return stage.getBoundingClientRect();
    }

    function setNoPos(x, y){
      noPos.x = x;
      noPos.y = y;
      noBtn.style.left = x + "px";
      noBtn.style.top = y + "px";
      noBtn.style.transform = "translate(-50%, -50%)";
    }

    function getNoClientCenter(){
      const r = noBtn.getBoundingClientRect();
      return { x: r.left + r.width/2, y: r.top + r.height/2, r };
    }

    function isFarFromHistory(p){
      for (const h of history){
        const d = Math.hypot(p.x - h.x, p.y - h.y);
        if (d < NO.historyMinSep) return false;
      }
      return true;
    }

    function pickNewNoPos(cursorClientX, cursorClientY){
      const sr = stageRect();
      const yesR = yesBtn.getBoundingClientRect();
      const noR = noBtn.getBoundingClientRect();

      const yesForbidden = inflateRect(yesR, NO.yesPad);

      const minX = NO.margin + noR.width/2;
      const maxX = sr.width - NO.margin - noR.width/2;
      const minY = NO.margin + noR.height/2;
      const maxY = sr.height - NO.margin - noR.height/2;

      const cursor = { x: cursorClientX - sr.left, y: cursorClientY - sr.top };
      const cur = { x: noPos.x, y: noPos.y };

      const away = { x: cur.x - cursor.x, y: cur.y - cursor.y };
      const awayLen = Math.hypot(away.x, away.y) || 1;
      const u = { x: away.x / awayLen, y: away.y / awayLen };

      function candidateToClientRect(p){
        return {
          left: sr.left + p.x - noR.width/2,
          right: sr.left + p.x + noR.width/2,
          top: sr.top + p.y - noR.height/2,
          bottom: sr.top + p.y + noR.height/2
        };
      }

      function ok(p){
        const dCursor = Math.hypot(p.x - cursor.x, p.y - cursor.y);
        if (dCursor < NO.safeDist) return false;

        if (!isFarFromHistory(p)) return false;

        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) return false;

        const cand = candidateToClientRect(p);
        if (rectsOverlap(cand, yesForbidden)) return false;

        return true;
      }

      let best = null;

      const tryCandidate = (p) => {
        if (!ok(p)) return;

        const dCursor = Math.hypot(p.x - cursor.x, p.y - cursor.y);

        const yesCenter = {
          x: (yesR.left + yesR.right)/2 - sr.left,
          y: (yesR.top + yesR.bottom)/2 - sr.top
        };
        const dYes = Math.hypot(p.x - yesCenter.x, p.y - yesCenter.y);

        const dMove = Math.hypot(p.x - cur.x, p.y - cur.y);

        const score = dCursor * 1.0 + dYes * 0.45 - dMove * 0.55;

        if (!best || score > best.score){
          best = { x: p.x, y: p.y, score };
        }
      };

      for (let i = 0; i < NO.samplesNear; i++){
        const a = (Math.random() - 0.5) * 0.9;
        const ca = Math.cos(a), sa = Math.sin(a);
        const ru = { x: u.x * ca - u.y * sa, y: u.x * sa + u.y * ca };

        const mag = NO.step + (Math.random() - 0.5) * 18;
        const p = {
          x: cur.x + ru.x * mag + (Math.random() - 0.5) * NO.jitter,
          y: cur.y + ru.y * mag + (Math.random() - 0.5) * NO.jitter
        };

        p.x = clamp(p.x, minX, maxX);
        p.y = clamp(p.y, minY, maxY);

        tryCandidate(p);
      }

      for (let i = 0; i < NO.samplesGlobal; i++){
        const p = {
          x: minX + Math.random() * (maxX - minX),
          y: minY + Math.random() * (maxY - minY)
        };
        tryCandidate(p);
      }

      if (best) return best;

      const corners = [
        { x: minX, y: minY },
        { x: maxX, y: minY },
        { x: minX, y: maxY },
        { x: maxX, y: maxY }
      ];
      corners.sort((a,b) => {
        const da = Math.hypot(a.x - cursor.x, a.y - cursor.y);
        const db = Math.hypot(b.x - cursor.x, b.y - cursor.y);
        return db - da;
      });
      return corners[0];
    }

    function spawnPuff(oldClient, newClient){
      const vx = newClient.x - oldClient.x;
      const vy = newClient.y - oldClient.y;
      const len = Math.hypot(vx, vy) || 1;

      const ux = -(vx / len);
      const uy = -(vy / len);

      const dx1 = ux * 10;
      const dy1 = uy * 10;
      const dx2 = ux * 34;
      const dy2 = uy * 34;

      const angle = Math.atan2(uy, ux) * 180 / Math.PI;

      const el = document.createElement("div");
      el.className = "puff";
      el.textContent = "üí®";
      el.style.left = oldClient.x + "px";
      el.style.top = oldClient.y + "px";
      el.style.setProperty("--rot", angle + "deg");
      el.style.setProperty("--dx1", dx1 + "px");
      el.style.setProperty("--dy1", dy1 + "px");
      el.style.setProperty("--dx2", dx2 + "px");
      el.style.setProperty("--dy2", dy2 + "px");
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 700);
    }

    function maybeEvade(clientX, clientY){
      const sr = stageRect();
      const cursor = { x: clientX - sr.left, y: clientY - sr.top };

      const d = Math.hypot(cursor.x - noPos.x, cursor.y - noPos.y);
      if (d >= NO.safeDist) return;

      const oldC = getNoClientCenter();
      const next = pickNewNoPos(clientX, clientY);

      setNoPos(next.x, next.y);

      const newC = getNoClientCenter();
      spawnPuff({ x: oldC.x, y: oldC.y }, { x: newC.x, y: newC.y });

      history.unshift({ x: next.x, y: next.y });
      history = history.slice(0, NO.historyN);
    }

    function onPointerMove(e){
      if (rafId) return;
      const x = e.clientX;
      const y = e.clientY;
      rafId = requestAnimationFrame(() => {
        rafId = null;
        maybeEvade(x, y);
      });
    }

    stage.addEventListener("pointermove", onPointerMove, { passive: true });
    stage.addEventListener("pointerdown", (e) => maybeEvade(e.clientX, e.clientY), { passive: true });

    function initButtons(){
      const sr = stageRect();

      const yesR = yesBtn.getBoundingClientRect();
      const noR = noBtn.getBoundingClientRect();

      const yesW = yesR.width || 120;
      const noW = noR.width || 120;

      let gap = 16;
      const available = sr.width - 2 * NO.margin;
      if (yesW + noW + gap > available) gap = 8;

      const centerX = sr.width / 2;
      const centerY = sr.height / 2;

      const yesX = centerX - (yesW/2 + gap/2);
      const noX  = centerX + (noW/2 + gap/2);

      yesBtn.style.left = clamp(yesX, NO.margin + yesW/2, sr.width - NO.margin - yesW/2) + "px";
      yesBtn.style.top = centerY + "px";
      yesBtn.style.transform = "translate(-50%, -50%)";

      setNoPos(
        clamp(noX, NO.margin + noW/2, sr.width - NO.margin - noW/2),
        clamp(centerY, NO.margin + noR.height/2, sr.height - NO.margin - noR.height/2)
      );

      history = [{ x: noPos.x, y: noPos.y }];
    }

    window.addEventListener("resize", () => {
      initButtons();
      resizeConfetti();
    }, { passive: true });

    function resizeConfetti(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      confettiCanvas.width = Math.floor(window.innerWidth * dpr);
      confettiCanvas.height = Math.floor(window.innerHeight * dpr);
      confettiCanvas.style.width = window.innerWidth + "px";
      confettiCanvas.style.height = window.innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeConfetti();

    const confetti = { on: false, parts: [], t0: 0 };

    function rand(a,b){ return a + Math.random() * (b-a); }
    function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

    function makePart(x, y, mode){
      const shape = pick(["rect","circle","ribbon"]);
      const hue = Math.floor(rand(0, 360));
      const color = `hsla(${hue}, 95%, 60%, 0.95)`;

      const size = shape === "ribbon" ? rand(10, 18) : rand(6, 14);
      const w = shape === "circle" ? size : size * rand(0.6, 1.4);
      const h = shape === "circle" ? size : size * rand(0.8, 2.2);

      let vx, vy;

      if (mode === "burst"){
        const a = rand(-Math.PI, 0);
        const sp = rand(4.5, 10.5);
        vx = Math.cos(a) * sp * rand(0.7, 1.2);
        vy = Math.sin(a) * sp * rand(0.7, 1.2);
      } else {
        vx = rand(-1.2, 1.2);
        vy = rand(2.8, 6.4);
      }

      return { x, y, vx, vy, w, h, shape, color, rot: rand(0, Math.PI*2), vr: rand(-0.22, 0.22), life: 0, ttl: rand(1100, 1900), swing: rand(0.6, 1.5), sway: rand(0.8, 2.4) };
    }

    function confettiBurst(cx, cy, n){
      for (let i = 0; i < n; i++){
        confetti.parts.push(makePart(cx + rand(-12, 12), cy + rand(-8, 8), "burst"));
      }
    }

    function confettiRain(n){
      for (let i = 0; i < n; i++){
        confetti.parts.push(makePart(rand(0, window.innerWidth), rand(-30, -5), "rain"));
      }
    }

    function drawPart(p){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;

      if (p.shape === "circle"){
        ctx.beginPath();
        ctx.arc(0, 0, p.w/2, 0, Math.PI*2);
        ctx.fill();
      } else if (p.shape === "ribbon"){
        ctx.beginPath();
        ctx.moveTo(-p.w/2, -p.h/2);
        ctx.quadraticCurveTo(0, 0, p.w/2, -p.h/2);
        ctx.quadraticCurveTo(0, p.h/2, -p.w/2, p.h/2);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      }

      ctx.restore();
    }

    function tickConfetti(ts){
      if (!confetti.on) return;

      const t = ts - confetti.t0;
      const dt = 16;

      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      const gravity = 0.12;
      const drag = 0.995;

      for (let i = confetti.parts.length - 1; i >= 0; i--){
        const p = confetti.parts[i];
        p.life += dt;

        p.vx *= drag;
        p.vy *= drag;
        p.vy += gravity;

        p.x += p.vx + Math.sin((p.life/180) * p.swing) * 0.35;
        p.y += p.vy + Math.cos((p.life/240) * p.sway) * 0.22;
        p.rot += p.vr;

        drawPart(p);

        const out = p.y > window.innerHeight + 80 || p.x < -120 || p.x > window.innerWidth + 120;
        const dead = p.life > p.ttl;

        if (out || dead) confetti.parts.splice(i, 1);
      }

      if (t < 380) confettiRain(14);

      if (confetti.parts.length === 0 && t > 900){
        confetti.on = false;
        confettiCanvas.classList.remove("on");
        return;
      }

      requestAnimationFrame(tickConfetti);
    }

    function startConfetti(){
      if (prefersReducedMotion) return;

      confetti.on = true;
      confetti.parts = [];
      confetti.t0 = performance.now();
      confettiCanvas.classList.add("on");

      const cx = window.innerWidth / 2;
      const cy = window.innerHeight * 0.35;

      confettiBurst(cx, cy, 120);
      setTimeout(() => confettiBurst(cx + 80, cy + 10, 90), 140);
      setTimeout(() => confettiBurst(cx - 90, cy + 15, 90), 260);

      requestAnimationFrame(tickConfetti);
    }

    requestAnimationFrame(() => initButtons());

    yesBtn.addEventListener("click", () => {
      startConfetti();
      viewAsk.classList.add("hidden");
      viewYes.classList.remove("hidden");

      if (isIOS) celebrateGif = forceRestartGif(celebrateGif, "celebrate.gif");
    });
  </script>
</body>
</html>
